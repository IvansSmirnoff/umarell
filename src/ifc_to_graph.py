#!/usr/bin/env python3
"""
ifc_to_graph.py

Import IfcSpace (rooms) from an IFC file into Neo4j.

Requirements:
  pip install ifcopenshell neo4j

Usage:
  python ifc_to_graph.py --ifc path/to/model.ifc --config sensor_config.json

The script will ensure that Room nodes have a `room_key` property that matches the keys
from `sensor_config.json` (e.g. "ifc_id_122131"). It attempts to match IfcSpace entries
by Name, LongName, GlobalId or other heuristics. For any unmapped keys the script will
create a placeholder Room node with only the `room_key` set.
"""

import argparse
import json
import os
import re
from neo4j import GraphDatabase

try:
    import ifcopenshell
except Exception:
    ifcopenshell = None


def load_config(path):
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f)


def normalize(text):
    if not text:
        return ''
    text = str(text)
    text = text.lower()
    text = re.sub(r"[^a-z0-9]+", " ", text)
    return text.strip()


def main(ifc_path, config_path):
    if ifcopenshell is None:
        raise RuntimeError("ifcopenshell is required. Install with `pip install ifcopenshell`.")

    config = load_config(config_path)
    room_keys = set(config.get('room_to_sensor_map', {}).keys())

    print(f"Loaded {len(room_keys)} room keys from config")

    model = ifcopenshell.open(ifc_path)
    spaces = model.by_type('IfcSpace')
    print(f"Found {len(spaces)} IfcSpace entities in IFC file")

    # Neo4j connection from env
    uri = os.environ.get('NEO4J_URI', 'bolt://neo4j:7687')
    user = os.environ.get('NEO4J_USER', 'neo4j')
    password = os.environ.get('NEO4J_PASSWORD', 'test')

    driver = GraphDatabase.driver(uri, auth=(user, password))

    matched_keys = set()

    with driver.session() as session:
        for space in spaces:
            name = getattr(space, 'Name', None)
            longname = getattr(space, 'LongName', None)
            globalid = getattr(space, 'GlobalId', None)
            p_name = normalize(name)
            p_long = normalize(longname)
            p_global = normalize(globalid)

            found_key = None
            # Heuristics: check for exact match of config key in fields
            for key in room_keys:
                k = normalize(key)
                if k == p_global or k == p_name or k == p_long:
                    found_key = key
                    break
                # also if the name contains a substring of the key or vice versa
                if k in p_name or k in p_long or p_name in k or p_long in k:
                    found_key = key
                    break

            # Fallback: try to match by numeric suffix (if config keys include numbers)
            if not found_key:
                nums = re.findall(r"\d+", normalize(name or '') + ' ' + normalize(globalid or ''))
                if nums:
                    for key in room_keys:
                        if any(n in key for n in nums):
                            found_key = key
                            break

            if found_key:
                matched_keys.add(found_key)
                props = {
                    'room_key': found_key,
                    'name': name or longname or None,
                    'long_name': longname or None,
                    'globalid': globalid or None,
                }
                cypher = (
                    "MERGE (r:Room {room_key: $room_key})\n"
                    "SET r.name = $name, r.long_name = $long_name, r.globalid = $globalid"
                )
                session.run(cypher, props)
                print(f"Mapped IfcSpace (GlobalId={globalid}) -> room_key={found_key}")
            else:
                # Create a Room node derived from IFC info with an autogenerated key (if no match)
                temp_key = f"ifc_auto_{globalid}" if globalid else None
                if temp_key:
                    props = {
                        'room_key': temp_key,
                        'name': name or longname or None,
                        'long_name': longname or None,
                        'globalid': globalid or None,
                    }
                    cypher = (
                        "MERGE (r:Room {room_key: $room_key})\n"
                        "SET r.name = $name, r.long_name = $long_name, r.globalid = $globalid"
                    )
                    session.run(cypher, props)
                    print(f"Created Room node with autogenerated key {temp_key}")

        # Ensure unmapped config keys exist as Room nodes (placeholders)
        for key in room_keys - matched_keys:
            session.run("MERGE (r:Room {room_key: $room_key})", {'room_key': key})
            print(f"Created placeholder Room node for config key {key}")

    driver.close()
    print("IFC import complete.")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Import IfcSpace as Room nodes into Neo4j')
    parser.add_argument('--ifc', required=True, help='Path to IFC file')
    parser.add_argument('--config', default='sensor_config.json', help='Path to sensor_config.json')
    args = parser.parse_args()

    main(args.ifc, args.config)
